
% only for XSB prolog
% :- [basics].

% general functions needed
% ---------------------------------------
:- dynamic(prevId/1).
:- dynamic(writId/1).

:- dynamic(signed/3).
:- dynamic(policy/2).
:- dynamic(internal/3).
:- dynamic(rule/3).
:- dynamic(peerName/1).
:- dynamic(proof/1).

:- include('tools.min').

% load the properties of the current peer
%:- include('local_properties.min').

init :- 
    retractall(writId(_)),
    asserta(writId(0)).

writeId(NewId) :-
     retract(writId(Id)),
     NewId is Id+1,
     asserta(writId(NewId)).

deb(N,List) :-
     writelist(N,List).
deb(List) :-
     writelist(0,List).

% begin meta meta interpreter
% ---------------------------------------

% tree(Id, Goal, Subqueries, Proof, Status, (Requester,QueryId)) -> Status = ready, waiting or failed
%         Ready: it is in the queue and it has not been processed yet
%	  Waiting: it has been processed but it is waiting from an answer from other peer
%	  Failed: it is in the queue but the query has failed in another peer
% query(Query, Internal) -> Internal = yes, no
     
% we use two special infix operators
% infix operator definition for @ (remote predicate call)
:- op(600, yfx, @).

% infix operator definition for $ (operator to express calling peer)
%:- op(601, xfy, $).
:- op(601, yfx, $).

% META-INTERPRETER

processTree(tree(_Goal,_Queries,_Proof,_Requester),[]) :-
	\+(peerName(_Peer)),!,
	writelist_debug(['PeerName is not set']).

processTree(tree(Goal,Queries,Proof,Requester),Results) :-
    selectQuery(query(Query,Internal),Queries,RestQueries),
    findall(tree(FinalGoal,NewQueries,NewProof,Delegator,RemoteGoal),
	metaQuery(tree(Goal,query(Query,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator,RemoteGoal)),
	Results).

selectQuery(Query,[Query|Rest], Rest).

addQueries(Guard,Body,RestQueries,NewListQueries,Internal) :-
     append(Guard,Body,NewList),
     createQueries(NewList,Internal,QueryList),
     append(QueryList,RestQueries,NewListQueries).

createQueries([],_,[]).
createQueries([H|T],Internal,[query(H,Internal)|Rest]) :-
     createQueries(T,Internal,Rest).

addQueryStrategy(Query,QueryList,NewQueryList) :-
     append(Query,QueryList,NewQueryList).

% addProof(NewFact,OldProof,NewProof,InternalRule)
addProof(NewFact,OldProof,NewProof,no) :-
     peerName(Peer), !,
     append(OldProof,[NewFact @ Peer],NewProof).
addProof(_,Proof,Proof,yes).

:- dynamic(markSignal/0).
mark :- \+(markSignal),!,asserta(markSignal).
mark.
checkMark :- \+(markSignal).
demark :- retractall(markSignal).

% begin meta interpreter
% ---------------------------------------

%metaQuery(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator,RemoteGoal)) :-
%	( (\+(Goal = _ $ _))
%	-> NewGoal = Goal $ Requester
%	; NewGoal = Goal
%	),
%    writelist_debug(['metaQuery - ',FinalGoal, ' - ', NewGoal, ' - ', Internal, ' - ', RestQueries, ' - ', Proof, ' - ', Requester]),
%    meta(tree(FinalGoal,query(Goal $ Requester,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator,RemoteGoal)).

%metaQuery(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator,RemoteGoal)) :-
%    \+(Goal = _ $ _),
%    writelist_debug(['entra sin requester',FinalGoal, ' - ', Goal, ' - ', Internal, ' - ', RestQueries, ' - ', Proof, ' - ', Requester]),
%    meta(tree(FinalGoal,query(Goal $ Requester,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator,RemoteGoal)).

metaQuery(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator,RemoteGoal)) :-
    writelist_debug(['entra ',FinalGoal, ' -  ', Goal, ' -  ', Internal, ' - ', RestQueries, ' -  ', Proof, ' - ', Requester]),
    meta(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator,RemoteGoal)).

% meta(tree(Goal,query(Query,Internal),RestQueries,Proof,Requester),treeR(Goal,NewQueries,NewProof,Delegator)),

meta(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,nil,nil)) :-
     demark,
     writelist_debug(['checking local']),
     local(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof)),
     writelist_debug(['local passed']),
     mark.
meta(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator,RemoteGoal)) :-
     checkMark,
     writelist_debug(['checking remote']),
%     writelist(['entra ',FinalGoal, ' ', Goal, ' ', Internal, ' ', RestQueries, ' ', Proof, ' ', Requester]),
     remote(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator,RemoteGoal)),
     writelist_debug(['remote passed']).

% local(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof))
% remote(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator))

% simplify 'Goal @ Issuer @ Issuer' to 'Goal @ Issuer'
% Remark: this rule will become clear later, when we introduce credentials

local(tree(FinalGoal,query(Goal @ Issuer1 @ Issuer2,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof)) :-
     Issuer1 == Issuer2, !, 
     write_actions(['simplify ', Goal @ Issuer1 @ Issuer2, ' to ', Goal @ Issuer1]),
     local(tree(FinalGoal,query(Goal @ Issuer1,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof)).

remote(tree(FinalGoal,query(Goal @ Issuer1 @ Issuer2,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator,RemoteGoal)) :-
     Issuer1 == Issuer2, !, 
     write_actions(['simplify ', Goal @ Issuer1 @ Issuer2, ' to ', Goal @ Issuer1]),
     remote(tree(FinalGoal,query(Goal @ Issuer1,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator,RemoteGoal)).

% evaluate Prolog constraints directly
local(tree(FinalGoal,query(constraint(Goal),_),RestQueries,Proof,_),treeR(FinalGoal,RestQueries,Proof)) :-
     !, write_actions(['evaluating constraint ', Goal]),
     call(Goal).

% expand goal with requester
local(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof)) :-
	\+(Goal = _ $ _),
	local(tree(FinalGoal,query(Goal $ Requester,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof)).

remote(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator)) :-
	\+(Goal = _ $ _),
	remote(tree(FinalGoal,query(Goal $ Requester,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof,Delegator)).

% now let's look at proving single literal goals

% check if there is a policy for the current signed rule

local(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,NewQueries,NewProof)) :-	
	 writelist_debug(['checking for policy for goal: ', Goal]),
         signed(rule(Goal, Guard, Body), Issuer, Credential),
	 writelist_debug(['signed rule found']),
	 checkPolicy(Goal, ExtraGuards, Requester), !,
	 writelist_debug(['policy rule found with literals: ', ExtraGuards]),
%	 selectQuery(NewGoal,ExtraGuards,RestExtraGuards),
%	 append(Guard,Body,SignedQueries),
  addQueries(Guard,Body,RestQueries,NewListQueries,Internal),
%	 append(ExtraGuards,SignedQueries,NewRestQueries),
  addQueries(ExtraGuards,[],NewListQueries,NewQueries,Internal),
%	 append(NewRestQueries,RestQueries,NewQueries),
	 addProof(signed(r(Goal,Guard,Body),Issuer,Credential),Proof,ModifiedProof,Internal),
	 addProof(policy(Goal,ExtraGuards),ModifiedProof,NewProof,Internal).
%	 local(tree(FinalGoal,query(NewGoal,Internal),FinalRestQueries,NewModifiedProof,Requester),treeR(FinalGoal,NewQueries,NewProof)).

checkPolicy(Goal,ExtraGuards,_) :-
    policy(Goal,ExtraGuards),!.
checkPolicy(Goal,ExtraGuards,Requester) :-
	\+(Goal == _ $ _),
    policy(Goal $ Requester, ExtraGuards).

% we do not allow direct access from external peers to internal
% predicates, which we store as special 'internal' rules
internal(Goal) :-
    internal(Goal, _, _).
internal([Goal | _]) :-
    internal(Goal, _, _).
internal([_ | Rest]) :-
    internal(Rest).

% if we have a single Goal, we search for rules with Goal in their
% head, and then evaluate their guard and body literals
local(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,_),treeR(FinalGoal,NewQueries,NewProof)) :-
    writelist_debug(['checking for rule for goal: ', Goal]),
%    writelist_debug(['guard -', Guard, '- Body -', Body, '-']),
    rule(Goal, Guard, Body),
	writelist_debug(['rule selected']),
    peerName(Peer),
    write_actions([Peer, ' is using rule: ', Goal, ' if ', Body, ' protected by ', Guard]),
    addProof(r(Goal,Guard,Body),Proof,NewProof,Internal),
    addQueries(Guard,Body,RestQueries,NewQueries,Internal).

% internal rules can be used in the context of an internal computation
% just like ordinary rules, but we will not include them in the proof

local(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,_),treeR(FinalGoal,NewQueries,NewProof)) :-
    writelist_debug(['checking for internal rule for goal: ', Goal]),
    internal(Goal, Guard, Body),
    peerName(Peer),
    write_actions([Peer, ' is using internal rule: ', Goal, ' if ', Body, ' protected by ', Guard]),
    addProof(r(Goal,hidden,hidden),Proof,NewProof,Internal),
    addQueries(Guard,Body,RestQueries,NewQueries,yes).

% and, of course, a Peer can also prove a 'Goal @ Issuer', if he has a
% signed rule for it
local(tree(FinalGoal,query(Goal,Internal),RestQueries,Proof,_),treeR(FinalGoal,NewQueries,NewProof)) :-
    writelist_debug(['checking for signed rule for goal: ', Goal]),
    signed(rule(Goal, Guard, Body), Issuer, Credential),
    (Goal = _ @ Issuer ; Goal = _ @ Issuer $ _),
    peerName(Peer),
    write_actions([Peer, ' is using signed rule: ', Goal, ' if ', Body, ' protected by ', Guard, ', certified by ', Credential]),
    addQueries(Guard,Body,RestQueries,NewQueries,Internal),
    addProof(signed(r(Goal,Guard,Body),Issuer,Credential),Proof,NewProof,Internal).

% we try to call the remote peer, but only if we do not find a signed
% rule (i.e. we can use signed rules as a cache)

% we will not use this rule if Goal itself is a 
% 'Goal @ Peer' structure
remote(tree(FinalGoal,query(Goal @ Issuer,_),RestQueries,Proof,_),treeR(FinalGoal,RestQueries,Proof,Issuer,Goal)) :-
	writelist_debug(['Remote1']),
	peerName(Peer),
	writelist_debug(['Remote1 - Peer = ',Peer, ' - Issuer = ', Issuer, ' - Goal = ', Goal]),
	\+(Peer = Issuer),
	\+(Goal = _ @ _),
	\+(signed(rule(Goal @ Issuer, _, _), _, _)),
	writelist_debug(['Finishing remote 1']), !.

% we also have a variant, which changes/remove the requester to the current peer
% (can also be a chain of requesters)
remote(tree(FinalGoal,query(Goal @ Issuer $ Req,_),RestQueries,Proof,Requester),treeR(FinalGoal,RestQueries,Proof,Issuer,Goal)) :- % $ Peer)) :-
	writelist_debug(['Remote2']),
     peerName(Peer),
     writelist_debug(['Remote2 - Peer = ',Peer, ' - Issuer = ', Issuer, ' - Requester = ', Requester, ' - Req = ', Req, ' - Goal = ', Goal]),     
     \+(Peer = Issuer),
     \+(Peer = Requester),
     \+(Goal = _ @ _),
     \+(signed(rule(Goal @ Issuer, _, _), _, _)),
     writelist_debug(['Finishing remote 2']),!.

% To make it possible for peers to answer queries we will also assume,
% that they can possess signed versions of clauses from other peers,
% so that they can answer on behalf of these other peers. We will use
% signed rules 'signed(Rule, Credential, Issuer)', where 'Rule' has
% the usual rule structure 'rule(Goal, Guard, Body, Issuer)', which
% tell us that the truth of 'Clause' is certified by the 'Credential',
% issued by 'Issuer'.  
% we use cached and signed rules like ordinary rules, but include 
% 'Credential' in the proof tree
% we represent these credentials as lists of 'attribute(value)' terms

% so we can also ask not the Issuer, but another Delegate about a
% certain goal (this is the second clause using the remote_call
% predicate)

% in this case, however, the proof has to be properly signed
remote(tree(FinalGoal,query(Goal @ Issuer @ Delegate,Internal),RestQueries,Proof,_),treeR(FinalGoal,RestQueries,NewProof,Delegate,Goal @ Issuer)) :-
     \+(Issuer == Delegate), !, % cut here, we always transfer control
                                % to Delegate in this case
      % we allow 'Goal @ Issuer' to be proved at the 'Delegate'
     addProof(proved_by(Delegate),Proof,NewProof, Internal).
      % properly_signed could ask for all pieces of the
      % proof to be signed (i.e. a complete credential chain), but this
      % might be too much?
      % not checked right now
      % properly_signed(ProofGoal).

% and the variant for transmitting the Requester (or Requester chain):
remote(tree(FinalGoal,query(Goal @ Issuer @ Delegate,Internal),RestQueries,Proof,Requester),treeR(FinalGoal,RestQueries,NewProof,Delegate,Goal @ Issuer)) :-
    peerName(Peer),
    \+(Requester = Peer),
    \+(Issuer == Delegate), !, % cut here, we always transfer control
                                 % to Delegate in this case
    % we allow 'Goal @ Issuer' to be proved at the 'Delegate'
     addProof(proved_by(Delegate),Proof,NewProof,Internal).

unification(old(Goal,CurrentQuery,RestQueries),ResolvedQuery,new(Goal,RestQueries)) :-
    writelist_debug(['Unificando ', CurrentQuery, ' with ', ResolvedQuery, ' - Goal: ', Goal]),
    CurrentQuery = ResolvedQuery.

% validateProof(Goal, Proof)
validateProof(Goal, Proof) :-
	removeProof,
	writelist_debug(['Proof cleaned']),
	insertProof(Proof),
	writelist_debug(['Proof asserted']),
	validate([Goal]).

removeProof :-
	retractall(proof(_)).

insertProof([]).
insertProof([proved_by(_)@_|R]) :- !,
	   insertProof(R).
	   
insertProof([F|R]) :-
	asserta(proof(F)),
	insertProof(R).

validate([]).

validate([Goal|GoalTail]) :-
	writelist_debug(['Validating goal ', Goal]),
	validateTop(Goal,NewGoals),
	append(NewGoals,GoalTail,NewList),
	validate(NewList).

validateTop(Goal,NewGoals) :-
	validateGoal(r(Goal,_,_)@_, NewGoals).
validateTop(Goal,NewGoals) :-
	validateGoal(signed(r(Goal,_,_),_,_)@_,NewGoals).

	
validateGoal(r(Goal,hidden,hidden)@Peer,[]) :-
	writelist_debug(['Checking hidden goal ', Goal]),
	proof(r(Goal,hidden,hidden)@Peer),
	writelist_debug(['Validate hidden goal ', Goal]).

validateGoal(r(Goal,Guards,Body)@Peer,List) :-
	writelist_debug(['Checking rule goal ', Goal]),
	proof(r(Goal,Guards,Body)@Peer),
	writelist_debug(['Validate rule goal ', Goal]),
	append(Guards,Body,List).

validateGoal(signed(r(Goal @Peer1 @Peer2,Guards,Body)@Peer,Issuer,Signature),List) :-
	writelist_debug(['Checking signed @ goal ', Goal]),
	proof(signed(r(Goal @Peer1,Guards,Body)@Peer2,Issuer,Signature)),
	writelist_debug(['Validate signed @ goal ', Goal]),	
	append(Guards,Body,List).

validateGoal(signed(r(Goal,Guards,Body)@Peer,Issuer,Signature),List) :-
	writelist_debug(['Checking signed goal ', Goal]),
	proof(signed(r(Goal,Guards,Body)@Peer,Issuer,Signature)),
	writelist_debug(['Validate signed goal ', Goal]),	
	append(Guards,Body,List).

% same version with $
validateGoal(r(Goal,hidden,hidden)@Peer,[]) :-
	writelist_debug(['Checking hidden $ goal ', Goal]),
	proof(r(Goal $ _,hidden,hidden)@Peer),
	writelist_debug(['Validate hidden $ goal ', Goal]).

validateGoal(r(Goal,Guards,Body)@Peer,List) :-
	writelist_debug(['Checking rule $ goal ', Goal]),
	proof(r(Goal $ _,Guards,Body)@Peer),
	writelist_debug(['Validate rule $ goal ', Goal]),
	append(Guards,Body,List).

validateGoal(signed(r(Goal,Guards,Body)@Peer,Issuer,Signature),List) :-
	writelist_debug(['Checking signed $ goal ', Goal]),
	proof(signed(r(Goal $ _,Guards,Body)@Peer,Issuer,Signature)),
	writelist_debug(['Validate signed $ goal ', Goal]),	
	append(Guards,Body,List).	
	

:- dynamic(runningpeer/2).
:- dynamic(maxdepth/1).
:- dynamic(debug_on/0).
