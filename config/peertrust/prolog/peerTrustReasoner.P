

% TODO currently using aliases. It is needed to find a way to specify the whole DN + issuer of the DN
% TODO add @ and @@
% TODO check that the Issuer is not "self"
% TODO add here builtin predicates (e.g., in(p(X),rdf:metadata()) )


%%% --------------------------------------------------------------------------------------------------
%%% Basic Predicates
%%% --------------------------------------------------------------------------------------------------

self_alias(Alias) :-
	providedSelfAlias(Alias).

check_init :-
	self_alias(_Peer),!.

check_init :-
	\+(self_alias(_Peer)),!,
	log_error(['Peer name alias is not set']),
	fail.

%%% --------------------------------------------------------------------------------------------------
%%% High Level Calls (to be made from an application)
%%% --------------------------------------------------------------------------------------------------

initReasoner :-
	init(kbCounter).

setSelfAlias(Alias) :-
	retractall(providedSelfAlias(_Name)),
	assert(providedSelfAlias(Alias)).

setDebugMode :-
	assert(debug_on).

% insert rules in the KB. KB may refer to
%    - kb: in the main KB (for self information, like e.g. policies)
%    - sideKB: in the side KB (for external information, like e.g. filtered policies)

requestInsertRules(request(NegId,Rules,AddOrAddNew,KB)) :-
	emptyRules(NegId,AddOrAddNew,KB),
	insertRules(NegId,Rules,KB).

requestExtractLocalActions(request(NegId,Goal,Requester), ActionList) :-
	log_debug(['Request ',requestExtractLocalActions(request(NegId,Goal,Requester), ActionList),' received.']),
	check_init,
	extractActions(NegId,Goal,Requester,extractLocalActions),
	retrieveExtractedActions(NegId,extractLocalActions,ActionList).

requestFiltering(request(NegId,Goal,Requester),FilteredRuleList) :-
	log_debug(['Request ',requestFiltering(request(NegId,Goal,Requester),FilteredRuleList),' received.']),
	check_init,
	findall(RuleList,filterRules(NegId,Goal,Requester,RuleList),AllRuleLists),
	log_filtering(['Retrieved set of filtered rules:',AllRuleLists]),
	cleanRuleList(NegId,AllRuleLists,FilteredRuleList).

requestExtractRequesterActions(request(NegId,Goal,Requester), ActionList) :-
	log_debug(['Request ',requestExtractRequesterActions(request(NegId,Goal,Requester), ActionList),' received.']),
	check_init,
	extractActions(NegId,Goal,Requester,extractRequesterActions),
	retrieveExtractedActions(NegId,extractRequesterActions,ActionList).


%%% --------------------------------------------------------------------------------------------------
%%% Shared Predicates
%%% --------------------------------------------------------------------------------------------------

% if not specified, by default filtering mode is assumed
findTerm(NegId,ElementId,Term) :-
	findTerm(NegId,filtering,ElementId,Term).

findTerm(NegId,extractRequesterActions,_ElementId,Term) :-
	sideKB(NegId,Term).
findTerm(_NegId,EvaluationType,ElementId,Term) :-
	member(EvaluationType,[evaluate,localEvaluate,extractLocalActions,filtering]),
	element(ElementId,Term).

init(kbCounter) :- 
    retractall(kbCounter(_X)),
    asserta(kbCounter(0)).

getNewId(kbCounter,NewId) :-
     retract(kbCounter(Id)),
     NewId is Id+1,
     asserta(kbCounter(NewId)).

emptyRules(_NegId,add,_KB) :- !.
emptyRules(_NegId,addNew,kb) :-
	retractall(element(_Id,_Rule)).
emptyRules(NegId,addNew,sideKB) :-
	retractall(sideKB(NegId,_Rule)).

insertRules(_NegId,[],_KB) :- !.
insertRules(NegId,[Rule|Rest],kb) :-
	!,
	getNewId(kbCounter,NewId),
	assert(element(NewId,Rule)),
	insertRules(NegId,Rest,kb).
insertRules(NegId,[Rule|Rest],sideKB) :-
	!,
	assert(sideKB(NegId,Rule)),
	insertRules(NegId,Rest,sideKB).
		       
cleanRuleList(NegId,AllRuleLists,FilteredRuleList) :-
	selectRules(NegId,AllRuleLists),
	findall(Rule,retract(selectedFilteredRule(NegId,Rule)),FilteredRuleList).

selectRules(_NegId,[]) :- !.
selectRules(NegId,[List|Rest]) :-
	selectRulesFromList(NegId,List),
	selectRules(NegId,Rest).

selectRulesFromList(_NegId,[]) :- !.
selectRulesFromList(NegId,[Rule|Rest]) :-
	insertIfNew(NegId,Rule),
	selectRulesFromList(NegId,Rest).

insertIfNew(NegId,Rule) :-
	selectedFilteredRule(NegId,Rule),!.
insertIfNew(NegId,Rule) :-
	asserta(selectedFilteredRule(NegId,Rule)).


% Assert the rules into the KB and adds a global identifier to the rule
% TODO provide the possibility to assert any rule
addElement(rule(Head,Guards,Body)) :-
	Id = newID,
	assert(rule(Id,Head,Guards,Body)).

%%% --------------------------------------------------------------------------------------------------
%%% Extract Actions
%%% --------------------------------------------------------------------------------------------------

% retrieves a list of actions to be executed
%     NOTE1: whenever a literal to be executed by the requester is found, the rest of the SLD tree is not checked and
%            its actions not extracted, only alternative solutions. That is, only actions that do not depend on unsatisfied
%            "requester actions" are selected
%     NOTE2: in this case internal predicates do not pose any special situation.
%     TODO probably remove the internal variable of all predicates
            

% asserts each action selected
extractActions(NegId,Goal,Requester,EvaluationType) :-
	extractLeafPredicates(NegId,Goal,Requester,EvaluationType),
	fail.
extractActions(_NegId,_Goal,_Requester,_EvaluationType).

% retrieves all selected actions
retrieveExtractedActions(NegId,extractLocalActions,ActionList) :-
	findall(Action, retract(selectedForSelfExecution(NegId,Action)),ActionList).

retrieveExtractedActions(NegId,extractRequesterActions,ActionList) :-
	findall(Action, retract(selectedForRequesterExecution(NegId,Action)),ActionList).

extractLeafPredicates(NegId,_Goal,_Requester,extractLocalActions) :-
	retractall(selectedForSelfExecution(NegId,_Action)).
extractLeafPredicates(NegId,_Goal,_Requester,extractRequesterActions) :-
	retractall(selectedForRequesterExecution(NegId,_Action)).
extractLeafPredicates(NegId,Goal,Requester,EvaluationType) :-
	processTerm(NegId,Goal,Requester,EvaluationType).


% 4 ways of evaluation:
% - extractLocalActions: extracts actions to be executed locally (by self)
% - extractRequesterActions: extracts actions to be executed by requester
% - evaluate: fully evaluates against the state
% - localEvaluate: evaluates against the state except actions dependent of Requester which are ignored.
% - filteredEvaluate: evaluates against the sideKB and accepts blurred as a synonim of true.

processTerms(_NegId,[],_Requester,_EvaluationType) :- !.
processTerms(NegId,[Goal|List],Requester,EvaluationType) :-
	processTerm(NegId,Goal,Requester,EvaluationType),
	processTerms(NegId,List,Requester,EvaluationType).


% If @ is nested with same Issuer, it may be simplified
processTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Can ',Goal,' be simplified?']),
	Goal = '@'('@'(G, Issuer), Issuer),
	!,
	log_processing(['Simplifying ',Goal]),
	processTerm(NegId,'@'(G, Issuer),Requester,EvaluationType).

% If the term is found locally, then remote elements are not checked.
% TODO local process term should include the builtins (package calls)
processTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Start local process of ',Goal]),
	demark(Goal),
	localProcessTerm(NegId,Goal,Requester,EvaluationType),
	log_processing(['Local match found.']),
	mark(Goal).

% If the term is not found locally, then remote elements are checked.
processTerm(NegId,Goal,Requester,EvaluationType) :-
	checkMark(Goal),
	log_processing(['Start remote process of ',Goal]),
	remoteProcessTerm(NegId,Goal,Requester,EvaluationType),
	log_processing(['Remote match found.']).

% FILTERED LITERALS

% In the case of evaluating a filtered policy, then blurred is a valid symbol
localProcessTerm(_NegId,blurred,_Requester,EvaluationType) :-
	member(EvaluationType,[extractRequesterActions,filteredEvaluate]),
	!.

% NORMAL LOCAL RULES

% Constraints
localProcessTerm(_NegId,Goal,_Requester,_EvaluationType) :-
	log_processing(['Is ',Goal,' a constraint?']),
	Goal = constraint(Constraint),
	!,
	log_processing(['Calling ',Goal]),
	call(Constraint),
	log_processing(['Call to ',Constraint,' successful']).

% TODO add a localProcessTerm for the builtin predicates

% Rules
localProcessTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Is ',Goal,' a rule?']),
	findTerm(NegId,EvaluationType,_RuleId,rule(Goal,Guards,Body)),
	log_processing([Goal,' is a rule.']),
	processTerms(NegId,Guards,Requester,EvaluationType),
	processTerms(NegId,Body,Requester,EvaluationType).

% Signed rules
localProcessTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Is ',Goal,' a signed rule?']),
	(Goal = '@'(_, Issuer) ; Goal = '$'('@'(_ , Issuer), _)),
	findTerm(NegId,EvaluationType,_RuleId,signed(rule(Goal,Guards,Body),Issuer)),
	log_processing([Goal,' is a signed rule.']),
	processPolicy(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,EvaluationType),
	processTerms(NegId,Guards,Requester,EvaluationType),
	processTerms(NegId,Body,Requester,EvaluationType).

% INTERNAL LOCAL RULES

% If the Goal is private, no requests to Requester can be found from here
localProcessTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Is ',Goal,' an internal rule?']),
	findTerm(NegId,EvaluationType,_RuleId,rule(Goal,Guards,Body,private)),
	log_processing([Goal,' is a private rule.']),
	processTerms(NegId,Guards,Requester,EvaluationType),
	processTerms(NegId,Body,Requester,EvaluationType).

% Signed rules
localProcessTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Is ',Goal,' an internal signed rule?']),
	(Goal = '@'(_, Issuer) ; Goal = '$'('@'(_ , Issuer), _)),
	findTerm(NegId,EvaluationType,_RuleId,signed(rule(Goal,Guards,Body),Issuer,private)),
	log_processing([Goal,' is a private signed rule.']),
	processPolicy(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,private,EvaluationType),
	processTerms(NegId,Guards,Requester,EvaluationType),
	processTerms(NegId,Body,Requester,EvaluationType).

% As a last case, check if the requester can be added
localProcessTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Contains ',Goal,' the requester?']),
	\+(Goal = '$'(_,  _)),
	log_processing(['Adding the requester ($) to ',Goal]),
	remarkIfMarked(Goal,'$'(Goal, Requester)),
	processTerm(NegId,'$'(Goal, Requester),Requester,EvaluationType).

% if Goal one has been marked, then mark also Goal2
%     Example: if Goal was marked, Goal $ Requester should also be marked (or otherwise it will be checked remotely)
remarkIfMarked(Goal,Goal2) :-
	\+(checkMark(Goal)),!,
	log_debug(['Remarking ',Goal2]),
	mark(Goal2).
remarkIfMarked(_Goal,_Goal2).


% Checks if there exists a policy protecting a signed rule
processPolicy(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,EvaluationType) :-
	log_processing(['Has ',Goal,' a protecting policy?']),
	findTerm(NegId,EvaluationType,_RuleId,policy(signed(rule(Goal,Guards,Body),Issuer), Guards, Body)),
	log_processing([Goal,' has a protecting policy.']),
	!,
	processTerms(NegId,Guards,Requester,EvaluationType),
	processTerms(NegId,Body,Requester,EvaluationType).

% If a signed rule contains a requester ($), the policy has to contain it too
% If a signed rule does not contain a requester ($), the policy might or might not contain it (depends
%    on whether it needs it or not
% Therefore, we also check for policies with the Goal $ Requester
processPolicy(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,EvaluationType) :-
	\+(Goal = '$'(_, _)),
	log_processing(['Expanding ',Goal,' with requester for protecting policy search.']),
	processPolicy(NegId,signed(rule('$'(Goal, Requester),Guards,Body),Issuer),Requester,EvaluationType).
processPolicy(_NegId,_SignedRule,_Requester,_EvaluationType).
	

% REMOTE RULES

% requests to the other peer

remoteProcessTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Is ',Goal,' a remote predicate?']),
	Goal = '@'(_, Issuer),
	checkAlias(Issuer,EvaluationType),
	log_processing([Goal,' is a remote predicate.']),
	remoteSelect(NegId,Goal,Issuer,Requester,EvaluationType).

% if we are in filtered policies mode, we may make a call with our own alias as requester
checkAlias(_Issuer,EvaluationType) :-
	member(EvaluationType,[extractRequesterActions,filteredEvaluate]),
	!.

% in any other mode, this may not happen, so if issuer = self, then at this point the evaluation has failed
% TODO when using @ and @@ it may be different since we couldn't remove the @@ but if it was only @ then we could remove it

checkAlias(Issuer,_EvaluationType) :-
	self_alias(Alias),
	\+(Alias = Issuer).
	
% if in extractRequesterActions mode, extract if to be executed by requester and not in state
remoteSelect(NegId,Goal,Issuer,Requester,extractRequesterActions) :-
	Issuer = Requester,
	!,
	selectIfNotInFilteredState(NegId,Goal).

remoteSelect(NegId,Goal,Issuer,Requester,extractRequesterActions) :-
	\+(Issuer = Requester),
	inFilteredState(NegId,Goal).

% if in filteredEvaluate mode, simply check if Goal is in the filtered state
remoteSelect(NegId,Goal,_Issuer,_Requester,filteredEvaluate) :-
	!,
	inFilteredState(NegId,Goal).

% if in evaluation mode, simply check if Goal is in the state
remoteSelect(NegId,Goal,_Issuer,_Requester,evaluate) :-
	!,
	inState(NegId,Goal).

% if in local evaluation mode, if Goal is a local action, check if in the state, otherwise, ignore.

remoteSelect(NegId,Goal,Issuer,Requester,localEvaluate) :-
	\+(Issuer = Requester),
	!,
	inState(NegId,Goal).
remoteSelect(_NegId,_Goal,Issuer,Requester,localEvaluate) :-
	Issuer = Requester.

% if in extractLocalActions mode, check if it is to be executed by the requester or a different peer

remoteSelect(NegId,Goal,Issuer,Requester,extractLocalActions) :-
	Issuer = Requester,
	log_processing([Goal,' is a request to requester ',Requester]),
	failIfNotInState(NegId,Goal,Requester).

remoteSelect(NegId,Goal,Issuer,Requester,extractLocalActions) :-
	\+(Issuer = Requester),
	log_processing([Goal,' is a request to peer ',Issuer]),
	selectIfNotInState(NegId,Goal,Issuer).

failIfNotInState(NegId,Goal,_Requester) :-
	inState(NegId,Goal).

selectIfNotInState(NegId,Goal,_Requester) :-
	inState(NegId,Goal).

selectIfNotInState(NegId,Goal,_Requester) :-
	not(inState(NegId,Goal)),
	assert(selectedForSelfExecution(NegId,Goal)),
	log_processing([Goal,' selected for self execution.']).

inState(NegId,Goal) :-
	log_processing(['Is ',Goal,' in the state?']),
	state(_RuleId,NegId,_NegStep,notification(Goal,successful),_Proof),
	log_processing([Goal,' is in the state.']).

inFilteredState(NegId,Goal) :-
	log_processing(['Is ',Goal,' in the filtered state?']),
	sideKB(NegId,notification(Goal,successful)),
	log_processing([Goal,' is in the filtered state.']).

selectIfNotInFilteredState(NegId,Goal) :-
	inFilteredState(NegId,Goal).

selectIfNotInFilteredState(NegId,Goal) :-
	\+(inFilteredState(NegId,Goal)),
	log_processing([Goal,' is not in the filtered state.']),
	% we must remove the @ requester and instantiate any Requester occurrence with our alias
	self_alias(Alias),
	Goal = '@'(CleanedGoal, Requester),
	log_processing([Goal,' has Requester ',Requester,' and must be simplified with Alias ',Alias]),
	Alias = Requester,
	assert(selectedForRequesterExecution(NegId,CleanedGoal)),
	log_processing([CleanedGoal,' selected for requester execution.']).

%%% --------------------------------------------------------------------------------------------------
%%% Filtering
%%% --------------------------------------------------------------------------------------------------

filterRules(NegId,Goal,Requester,RuleList) :-
	filtering(NegId,Goal,Requester,public,[],RuleList),
	log_filtering(['New filtered set of policies found:',RuleList]).

filtering(NegId,Goal,Requester,Internal,RuleList,NewRuleList) :-
	filterTerm(in(NegId,Goal,_Goal,Requester,Internal,RuleList),out(_FilteredGoal,NewRuleList)).
	
% retrieves a list of filtered rules to be sent to the other party
%     NOTE1: whenever a literal to be executed by the requester is found, any other action to be executed by self in the rest of the SLD tree
%            is blurred. That is, no actions to be executed by self is in the set of filtered rules.
%     NOTE2: internal predicates are not shown in the set of fitered rules
            
filterTerms(in(_NegId,[],[],_Requester,_Internal,RuleList),out([],RuleList)) :- !.
filterTerms(in(NegId,[BoundGoal|BoundList],[UnboundGoal|UnboundList],Requester,Internal,RuleList),out(NewFilteredList,NewRuleList)) :-
	log_filtering(['Filtering terms ',BoundGoal|BoundList]),
	filterTerm(in(NegId,BoundGoal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,RuleList2)),
	filterTerms(in(NegId,BoundList,UnboundList,Requester,Internal,RuleList2),out(FilteredList,NewRuleList)),
	addToList(FilteredGoal,FilteredList,NewFilteredList),
	log_filtering(['Finished filtering terms ',BoundGoal|BoundList]).


% If @ is nested with same Issuer, it may be simplified
filterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)) :-
	log_filtering(['Can ',Goal,' be simplified?']),
	Goal = '@'('@'(G, Issuer), Issuer),
	!,
	log_filtering(['Simplifying ',Goal]),
	filterTerm(in(NegId,'@'(G, Issuer),UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)).

% If the term is found locally, then remote elements are not checked.
% TODO local process term should include the builtins (package calls)
filterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)) :-
	log_filtering(['Start local process of ',Goal]),
	demark(Goal),
	localFilterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)),
	log_filtering(['Local match found:',NewRuleList]),
	mark(Goal).

% If the term is not found locally, then remote elements are checked.
filterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)) :-
	checkMark(Goal),
	log_filtering(['Start remote process of ',Goal]),
	remoteFilterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)),
	log_filtering(['Remote match found:',Goal,' and NewRuleList=',NewRuleList]).
	

% NORMAL LOCAL RULES

% Constraints
localFilterTerm(in(_NegId,Goal,UnboundGoal,_Requester,_Internal,RuleList),out(UnboundGoal,RuleList)) :-
	log_filtering(['Is ',Goal,' a constraint?']),
	Goal = constraint(Constraint),
	!,
	log_filtering(['Calling ',Goal]),
	call(Constraint),
	log_filtering(['Call to ',Constraint,' successful']).

% TODO add a localProcessTerm for the builtin predicates
	
	
% Rules
localFilterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(UnboundGoal,NewRuleList)) :-
	log_filtering(['Is ',Goal,' a rule?']),
	findTerm(NegId,RuleId,rule(Goal,BoundGuards,BoundBody)),
	log_filtering([Goal,' is a rule: ',RuleId,' - ',rule(Goal,BoundGuards,BoundBody)]),
	findTerm(NegId,RuleId,rule(FilteredGoal,UnboundGuards,UnboundBody)),
	filterGuardsAndBody(in(NegId,Goal,BoundGuards,UnboundGuards,BoundBody,UnboundBody,Requester,Internal,RuleList),out(FilteredGuards,FilteredBody,RuleList2)),
	appendToListIfPublic(Internal,[rule(FilteredGoal,FilteredGuards,FilteredBody)],RuleList2,NewRuleList),
	log_filtering(['FilterTerm for rule finished with FilteredGoal=',UnboundGoal,' and NewRuleList=',NewRuleList]).

% Signed rules
localFilterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(UnboundGoal,NewRuleList)) :-
	log_filtering(['Is ',Goal,' a signed rule?']),
	(Goal = '@'(_, Issuer) ; Goal = '$'('@'(_ , Issuer), _)),
	findTerm(NegId,RuleId,signed(rule(Goal,Guards,Body),Issuer)),
	log_filtering([Goal,' is a signed rule: ',RuleId,' - ',signed(rule(Goal,Guards,Body),Issuer)]),
	findTerm(NegId,RuleId,signed(rule(FilteredGoal,UnboundGuards,UnboundBody),UnboundIssuer)),
	filterPolicy(in(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,Internal,RuleList),out(RuleList2)),
	filterGuardsAndBody(in(NegId,Goal,Guards,UnboundGuards,Body,UnboundBody,Requester,Internal,RuleList2),out(FilteredGuards,FilteredBody,RuleList3)),
	appendToListIfPublic(Internal,[signed(rule(FilteredGoal,FilteredGuards,FilteredBody),UnboundIssuer)],RuleList3,NewRuleList),
	log_filtering(['FilterTerm for rule finished with FilteredGoal=',UnboundGoal,' and NewRuleList=',NewRuleList]).
			    
% INTERNAL LOCAL RULES

% If the Goal is private, no requests to Requester can be found from here

% When an internal rules is found, no information from here is added to the set of filtered policies. 
%     However, two things may happen:
%     - Goal is ground: in this case Goal is then evaluated and its result may be
%       * true, in which case Goal is simply removed from the set of filtered policies
%       * false, in which case the current branch of the SLD tree fails
%     - Goal is not ground: in this case, no evaluation is performed and a symbol "blurred" is added to the set of filtered policies

% TODO I think I can remove all the Internal variables the way the code is now
			    
localFilterTerm(in(NegId,Goal,_UnboundGoal,Requester,_Internal,RuleList),out(FilteredGoal,RuleList)) :-
	log_filtering(['Is ',Goal,' an internal rule?']),
	findTerm(NegId,_RuleId,rule(Goal,Guards,Body,private)),
	log_filtering([Goal,' is a private rule:',rule(_RuleId,Goal,Guards,Body,private)]),
%	( (ground(Goal))
%	->
	processTerms(NegId,Guards,Requester,evaluate),
	processTerms(NegId,Body,Requester,evaluate),
	FilteredGoal = nil,
%	;
%	    FilteredGoal = blurred
%	),
	log_filtering(['FilterTerm for internal rule finished with FilteredGoal=',FilteredGoal,' and NewRuleList=',RuleList]).

% Signed rules
localFilterTerm(in(NegId,Goal,_UnboundGoal,Requester,_Internal,RuleList),out(FilteredGoal,RuleList)) :-
	log_filtering(['Is ',Goal,' an internal signed rule?']),
	(Goal = '@'(_, Issuer) ; Goal = '$'('@'(_ , Issuer), _)),
	findTerm(NegId,_RuleId,signed(rule(Goal,Guards,Body),Issuer,private)),
	log_filtering([Goal,' is a private signed rule: ',signed(_RuleId,rule(Goal,Guards,Body),Issuer,private)]),
%	( (ground(Goal))
%	->
	processPolicy(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,evaluate),
	processTerms(NegId,Guards,Requester,evaluate),
	processTerms(NegId,Body,Requester,evaluate),
	FilteredGoal = nil,
%	;
%	    FilteredGoal = blurred
%	),
	log_filtering(['FilterTerm for internal signed rule finished with FilteredGoal=',FilteredGoal,' and NewRuleList=',RuleList]).

% As a last case, check if the requester can be added
localFilterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)) :-
	log_filtering(['Contains ',Goal,' the requester?']),
	\+(Goal = '$'(_,  _)),
	log_filtering(['Adding the requester ($) to ',Goal]),
	remarkIfMarked(Goal,'$'(Goal, Requester)),
	filterTerm(in(NegId,'$'(Goal, Requester),UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)).

% Checks if there exists a policy protecting a signed rule
filterPolicy(in(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,Internal,RuleList),out(NewRuleList)) :-
	log_filtering(['Has ',Goal,' a protecting policy?']),
	findTerm(NegId,RuleId,policy(signed(rule(Goal,Guards,Body),Issuer), PolicyGuards, PolicyBody)),
	log_filtering([Goal,' has a protecting policy: ',RuleId,' - ',policy(signed(rule(Goal,Guards,Body),Issuer), PolicyGuards, PolicyBody)]),
	!,
	findTerm(NegId,RuleId,policy(signed(rule(UnboundGoal,UnboundGuards,UnboundBody),UnboundIssuer), UnboundPolicyGuards, UnboundPolicyBody)),
	filterGuardsAndBody(in(NegId,Goal,PolicyGuards,UnboundPolicyGuards,PolicyBody,UnboundPolicyBody,Requester,Internal,RuleList),out(FilteredPolicyGuards,FilteredPolicyBody,RuleList2)),
	appendToListIfPublic(Internal,[policy(signed(rule(UnboundGoal,UnboundGuards,UnboundBody),UnboundIssuer), FilteredPolicyGuards, FilteredPolicyBody)],RuleList2,NewRuleList),
	log_filtering(['FilterTerm for protecting policy finished with NewRuleList=',NewRuleList]).

% If a signed rule contains a requester ($), the policy has to contain it too
% If a signed rule does not contain a requester ($), the policy might or might not contain it (depends
%    on whether it needs it or not
% Therefore, we also check for policies with the Goal $ Requester
filterPolicy(in(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,Internal,RuleList),out(NewRuleList)) :-
	\+(Goal = '$'(_, _)),
	log_filtering(['Expanding ',Goal,' with requester for protecting policy search.']),
	filterPolicy(in(NegId,signed(rule('$'(Goal, Requester),Guards,Body),Issuer),Requester,Internal,RuleList),out(NewRuleList)).
filterPolicy(in(_NegId,signed(rule(_Goal,_Guards,_Body),_Issuer),_Requester,_Internal,RuleList),out(RuleList)).

% REMOTE RULES

% requests to the other peer
% if issuer = self, then at this point the evaluation has failed
% TODO when using @ and @@ it may be different since we couldn't remove the @@ but if it was only @ then we could remove it

remoteFilterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)) :-
	log_filtering(['Is ',Goal,' a remote predicate?']),
	Goal = '@'(_, Issuer),
	self_alias(Alias),
	\+(Alias = Issuer),
	log_filtering([Goal,' is a remote predicate.']),
	remoteFilterSelect(in(NegId,Goal,UnboundGoal,Issuer,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)),
	log_filtering(['FilterTerm for remote term finished with FilteredGoal=',FilteredGoal,' and NewRuleList=',NewRuleList]).

% check if it is to be executed by the requester or a different peer

remoteFilterSelect(in(NegId,Goal,UnboundGoal,Issuer,Requester,Internal,RuleList),out(UnboundGoal,NewRuleList)) :-
	Issuer = Requester,
	log_filtering([Goal,' is a request to requester ',Requester]),
	addIfInState(in(NegId,Goal,Internal,RuleList),out(NewRuleList)).

remoteFilterSelect(in(NegId,Goal,UnboundGoal,Issuer,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)) :-
	\+(Issuer = Requester),
	log_filtering([Goal,' is a request to peer ',Issuer]),
	blurredIfNotInState(in(NegId,Goal,UnboundGoal,Internal,RuleList),out(FilteredGoal,NewRuleList)).

blurredIfNotInState(in(NegId,Goal,UnboundGoal,Internal,RuleList),out(UnboundGoal,NewRuleList)) :-
	checkState(NegId,Goal,UnboundGoal),
	appendToListIfPublic(Internal,[notification(UnboundGoal,successful)],RuleList,NewRuleList).

% if it failed, fail.
checkState(NegId,Goal,_UnboundGoal) :-
	log_filtering(['Is ',Goal,' in the state as failure?']),
	state(_RuleId,NegId,_NegStep,notification(Goal,failed),_Proof),
	!,
	log_filtering([Goal,' is in the state as failure.']),
	fail.

checkState(NegId,Goal,blurred) :-
	\+(state(_RuleId,NegId,_NegStep,notification(Goal,successful),_Proof)),
	!.

% if it was successful, add to the set of filtered rules
checkState(NegId,Goal,UnboundGoal) :-
	log_filtering(['Is ',Goal,' in the state as successful?']),
	state(RuleId,NegId,_NegStep,notification(Goal,successful),_Proof),
	log_filtering([Goal,' is in the state.as successful']),
	state(RuleId,NegId,_NegStep,notification(UnboundGoal,successful),_Proof).

addIfInState(in(NegId,Goal,Internal,RuleList),out(NewRuleList)) :-
	log_filtering(['Is ',Goal,' in the state?']),
	state(RuleId,NegId,_NegStep,notification(Goal,successful),_Proof),
	log_filtering([Goal,' is in the state.']),
	state(RuleId,NegId,_NegStep,notification(UnboundGoal,successful),_Proof),	
	appendToListIfPublic(Internal,[notification(UnboundGoal,successful)],RuleList,NewRuleList).
addIfInState(in(NegId,Goal,_Internal,RuleList),out(RuleList)) :-
	\+(state(_RuleId,NegId,_NegStep,notification(Goal,successful),_Proof)).

% verifies whether Goal is satisfied but it does not instantiate variables
% verify(Goal) :- not( not( Goal )).


% adds to the list if the term is not nil
addToList(nil,List,List) :- !.
addToList(Term,List,[Term|List]).

appendToListIfPublic(Internal,List1,List2,NewList) :-
	( (Internal = private)
	->
	    NewList = List2
	;
	    append(List1,List2,NewList)
	).

filterGuardsAndBody(in(NegId,_Goal,BoundGuards,UnboundGuards,BoundBody,UnboundBody,Requester,Internal,RuleList),out(FilteredGuards,FilteredBody,NewRuleList)) :-
	log_filtering(['Filtering guards ',BoundGuards]),
	filterTerms(in(NegId,BoundGuards,UnboundGuards,Requester,Internal,RuleList),out(FilteredGuards,RuleList2)),
	conditionalFiltering(in(NegId,BoundGuards,BoundBody,UnboundBody,Requester,Internal,RuleList2),out(FilteredBody,NewRuleList)),
	log_filtering(['Conditional filtering finished with FilteredBody=',FilteredBody]).

conditionalFiltering(in(NegId,BoundGuards,BoundBody,UnboundBody,Requester,Internal,RuleList),out(FilteredBody,NewRuleList)) :-
	log_filtering(['Does ',BoundGuards,' evaluate to true?']),
	processTerms(NegId,BoundGuards,Requester,evaluate),
	log_filtering([BoundGuards,' evaluates to true.']),
	!,
	filterTerms(in(NegId,BoundBody,UnboundBody,Requester,Internal,RuleList),out(FilteredBody,NewRuleList)).
conditionalFiltering(in(_NegId,_BoundGuards,_BoundBody,_UnboundBody,_Requester,_Internal,RuleList),out([blurred],RuleList)).


% Extracts the 2nd level of an AND-OR tree where the parent is the goal and children are in a OR list where each sublist represents an AND set of children
%     e.g., [ [a,b] [c,d] ] which represents ( (a AND b) OR (c AND d) )


%% --------------------------

log_processing(List) :-
	log_debug(['processing: '|List]).
log_filtering(List) :-
	log_debug(['filtering: '|List]).

printResultTree(_) :- init,fail.
printResultTree(X) :-
	printResultSubTree(X).

printResultSubTree([]).
printResultSubTree([resultTree(Goal,SubQueries,Proof,Trace,RemoteGoal,Delegator)|Rest]) :-
	writelist(2,[Goal]),
	writelist(5,SubQueries),
	writelist(5,Proof),
	writelist(5,Trace),
	writelist(5,[RemoteGoal]),
	writelist(5,[Delegator]),nl,
	printResultSubTree(Rest).
