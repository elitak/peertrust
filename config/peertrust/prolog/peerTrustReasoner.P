

% TODO currently using aliases. It is needed to find a way to specify the whole DN + issuer of the DN
% TODO add @ and @@
% TODO check that the Issuer is not "self"
% TODO add here builtin predicates (e.g., in(p(X),rdf:metadata()) )


%%% --------------------------------------------------------------------------------------------------
%%% Basic Predicates
%%% --------------------------------------------------------------------------------------------------

self_alias(Alias) :-
	providedSelfAlias(Alias).

check_init :-
	self_alias(_Peer),!.

check_init :-
	\+(self_alias(_Peer)),!,
	log_error(['Peer name alias is not set']),
	fail.

%%% --------------------------------------------------------------------------------------------------
%%% High Level Calls
%%% --------------------------------------------------------------------------------------------------

setSelfAlias(Alias) :-
	retractall(providedSelfAlias(_Name)),
	assert(providedSelfAlias(Alias)).

setDebugMode :-
	assert(debug_on).

requestExtractActions(request(NegId,Goal,Requester), ActionList) :-
	log_debug(['Request ',requestExtractActions(request(NegId,Goal,Requester), ActionList),' received.']),
	check_init,
	extractActions(NegId,Goal,Requester),
	retrieveExtractedActions(NegId,ActionList).

% TODO whole filtering
requestFiltering(request(NegId,Goal,Requester),FilteredRuleList) :-
	log_debug(['Request ',requestFiltering(request(NegId,Goal,Requester),FilteredRuleList),' received.']),
	check_init,
	findall(RuleList,filterRules(NegId,Goal,Requester,RuleList),AllRuleLists),
	log_filtering(['Retrieved set of filtered rules:',AllRuleLists]),
	cleanRuleList(NegId,AllRuleLists,FilteredRuleList).





cleanRuleList(NegId,AllRuleLists,FilteredRuleList) :-
	selectRules(NegId,AllRuleLists),
	findall(Rule,retract(selectedFilteredRule(NegId,Rule)),FilteredRuleList).

selectRules(_NegId,[]) :- !.
selectRules(NegId,[List|Rest]) :-
	selectRulesFromList(NegId,List),
	selectRules(NegId,Rest).

selectRulesFromList(_NegId,[]) :- !.
selectRulesFromList(NegId,[Rule|Rest]) :-
	insertIfNew(NegId,Rule),
	selectRulesFromList(NegId,Rest).

insertIfNew(NegId,Rule) :-
	selectedFilteredRule(NegId,Rule),!.
insertIfNew(NegId,Rule) :-
	asserta(selectedFilteredRule(NegId,Rule)).

%insertIfNew(rule(RuleId,_Head,_Guards,_Body)) :-
%	selectedFilteredRule(rule(RuleId,_Head,_Guards,_Body)),!.
%insertIfNew(rule(RuleId,Head,Guards,Body)) :-
%	assert(selectedFilteredRule(rule(RuleId,Head,Guards,Body))).
% signed rule
%insertIfNew(signed(rule(RuleId,_Head,_Guards,_Body),_Issuer)) :-
%	selectedFilteredRule(signed(rule(RuleId,_Head,_Guards,_Body),_Issuer)),!.
%insertIfNew(signed(rule(RuleId,Head,Guards,Body),Issuer)) :-
%	assert(selectedFilteredRule(signed(rule(RuleId,Head,Guards,Body),Issuer))).


% Assert the rules into the KB and adds a global identifier to the rule
% TODO provide the possibility to assert any rule
addElement(rule(Head,Guards,Body)) :-
	Id = newID,
	assert(rule(Id,Head,Guards,Body)).

%%% --------------------------------------------------------------------------------------------------
%%% Extract Actions
%%% --------------------------------------------------------------------------------------------------

% retrieves a list of actions to be executed
%     NOTE1: whenever a literal to be executed by the requester is found, the rest of the SLD tree is not checked and
%            its actions not extracted, only alternative solutions. That is, only actions that do not depend on unsatisfied
%            "requester actions" are selected
%     NOTE2: in this case internal predicates do not pose any special situation.
%     TODO probably remove the internal variable of all predicates
            

% asserts each action selected
extractActions(NegId,Goal,Requester) :-
	extractLeafPredicates(NegId,Goal,Requester),
	fail.
extractActions(_NegId,_Goal,_Requester).

% retrieves all selected actions
retrieveExtractedActions(NegId, ActionList) :-
	findall(Action, retract(selectedForSelfExecution(NegId,Action)),ActionList).


extractLeafPredicates(NegId,_Goal,_Requester) :-
	retractall(selectedForSelfExecution(NegId,_Action)).
extractLeafPredicates(NegId,Goal,Requester) :-
	processTerm(NegId,Goal,Requester,extractActions).


% Three ways of evaluation:
% - extractActions: extracts action to be executed
% - evaluate: fully evaluates against the state
% - localEvaluate: evaluates against the state except actions dependent of Requester which are ignored.

processTerms(_NegId,[],_Requester,_EvaluationType) :- !.
processTerms(NegId,[Goal|List],Requester,EvaluationType) :-
	processTerm(NegId,Goal,Requester,EvaluationType),
	processTerms(NegId,List,Requester,EvaluationType).


% If @ is nested with same Issuer, it may be simplified
processTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Can ',Goal,' be simplified?']),
	Goal = '@'('@'(G, Issuer), Issuer),
	!,
	log_processing(['Simplifying ',Goal]),
	processTerm(NegId,'@'(G, Issuer),Requester,EvaluationType).

% If the term is found locally, then remote elements are not checked.
% TODO local process term should include the builtins (package calls)
processTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Start local process of ',Goal]),
	demark(Goal),
	localProcessTerm(NegId,Goal,Requester,EvaluationType),
	log_processing(['Local match found.']),
	mark(Goal).

% If the term is not found locally, then remote elements are checked.
processTerm(NegId,Goal,Requester,EvaluationType) :-
	checkMark(Goal),
	log_processing(['Start remote process of ',Goal]),
	remoteProcessTerm(NegId,Goal,Requester,EvaluationType),
	log_processing(['Remote match found.']).
	

% NORMAL LOCAL RULES

% Constraints
localProcessTerm(_NegId,Goal,_Requester,_EvaluationType) :-
	log_processing(['Is ',Goal,' a constraint?']),
	Goal = constraint(Constraint),
	!,
	log_processing(['Calling ',Goal]),
	call(Constraint),
	log_processing(['Call to ',Constraint,' successful']).

% TODO add a localProcessTerm for the builtin predicates

% Rules
localProcessTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Is ',Goal,' a rule?']),
	rule(_RuleId,Goal,Guards,Body),
	log_processing([Goal,' is a rule.']),
	processTerms(NegId,Guards,Requester,EvaluationType),
	processTerms(NegId,Body,Requester,EvaluationType).

% Signed rules
localProcessTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Is ',Goal,' a signed rule?']),
	(Goal = '@'(_, Issuer) ; Goal = '$'('@'(_ , Issuer), _)),
	signed(_RuleId,rule(Goal,Guards,Body),Issuer),
	log_processing([Goal,' is a signed rule.']),
	processPolicy(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,EvaluationType),
	processTerms(NegId,Guards,Requester,EvaluationType),
	processTerms(NegId,Body,Requester,EvaluationType).

% INTERNAL LOCAL RULES

% If the Goal is private, no requests to Requester can be found from here
localProcessTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Is ',Goal,' an internal rule?']),
	rule(_RuleId,Goal,Guards,Body,private),
	log_processing([Goal,' is a private rule.']),
	processTerms(NegId,Guards,Requester,EvaluationType),
	processTerms(NegId,Body,Requester,EvaluationType).

% Signed rules
localProcessTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Is ',Goal,' an internal signed rule?']),
	(Goal = '@'(_, Issuer) ; Goal = '$'('@'(_ , Issuer), _)),
	signed(_RuleId,rule(Goal,Guards,Body),Issuer,private),
	log_processing([Goal,' is a private signed rule.']),
	processPolicy(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,private,EvaluationType),
	processTerms(NegId,Guards,Requester,EvaluationType),
	processTerms(NegId,Body,Requester,EvaluationType).

% As a last case, check if the requester can be added
localProcessTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Contains ',Goal,' the requester?']),
	\+(Goal = '$'(_,  _)),
	log_processing(['Adding the requester ($) to ',Goal]),
	remarkIfMarked(Goal,'$'(Goal, Requester)),
	processTerm(NegId,'$'(Goal, Requester),Requester,EvaluationType).

% if Goal one has been marked, then mark also Goal2
%     Example: if Goal was marked, Goal $ Requester should also be marked (or otherwise it will be checked remotely)
remarkIfMarked(Goal,Goal2) :-
	\+(checkMark(Goal)),!,
	log_debug(['Remarking ',Goal2]),
	mark(Goal2).
remarkIfMarked(_Goal,_Goal2).


% Checks if there exists a policy protecting a signed rule
processPolicy(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,EvaluationType) :-
	log_processing(['Has ',Goal,' a protecting policy?']),
	policy(_RuleId,signed(rule(Goal,Guards,Body),Issuer), Guards, Body),
	log_processing([Goal,' has a protecting policy.']),
	!,
	processTerms(NegId,Guards,Requester,EvaluationType),
	processTerms(NegId,Body,Requester,EvaluationType).

% If a signed rule contains a requester ($), the policy has to contain it too
% If a signed rule does not contain a requester ($), the policy might or might not contain it (depends
%    on whether it needs it or not
% Therefore, we also check for policies with the Goal $ Requester
processPolicy(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,EvaluationType) :-
	\+(Goal = '$'(_, _)),
	log_processing(['Expanding ',Goal,' with requester for protecting policy search.']),
	processPolicy(NegId,signed(rule('$'(Goal, Requester),Guards,Body),Issuer),Requester,EvaluationType).
processPolicy(_NegId,_SignedRule,_Requester,_EvaluationType).


% REMOTE RULES

% requests to the other peer
% if issuer = self, then at this point the evaluation has failed
% TODO when using @ and @@ it may be different since we couldn't remove the @@ but if it was only @ then we could remove it

remoteProcessTerm(NegId,Goal,Requester,EvaluationType) :-
	log_processing(['Is ',Goal,' a remote predicate?']),
	Goal = '@'(_, Issuer),
	self_alias(Alias),
	\+(Alias = Issuer),
	log_processing([Goal,' is a remote predicate.']),
	remoteSelect(NegId,Goal,Issuer,Requester,EvaluationType).

% if in evaluation mode, simply check if Goal is in the state
remoteSelect(NegId,Goal,_Issuer,_Requester,evaluate) :-
	!,
	inState(NegId,Goal).

% if in local evaluation mode, if Goal is a local action, check if in the state, otherwise, ignore.

remoteSelect(NegId,Goal,Issuer,Requester,localEvaluate) :-
	\+(Issuer = Requester),
	!,
	inState(NegId,Goal).
remoteSelect(_NegId,_Goal,Issuer,Requester,localEvaluate) :-
	Issuer = Requester.

% if in extractActions mode, check if it is to be executed by the requester or a different peer

remoteSelect(NegId,Goal,Issuer,Requester,extractActions) :-
	Issuer = Requester,
	log_processing([Goal,' is a request to requester ',Requester]),
	failIfNotInState(NegId,Goal,Requester).

remoteSelect(NegId,Goal,Issuer,Requester,extractActions) :-
	\+(Issuer = Requester),
	log_processing([Goal,' is a request to peer ',Issuer]),
	selectIfNotInState(NegId,Goal,Issuer).

failIfNotInState(NegId,Goal,_Requester) :-
	inState(NegId,Goal).

selectIfNotInState(NegId,Goal,_Requester) :-
	inState(NegId,Goal).

selectIfNotInState(NegId,Goal,_Requester) :-
	not(inState(NegId,Goal)),
	assert(selectedForSelfExecution(NegId,Goal)),
	log_processing([Goal,' selected for self execution.']).

inState(NegId,Goal) :-
	log_processing(['Is ',Goal,' in the state?']),
	state(_RuleId,NegId,_NegStep,notification(Goal,successful),_Proof),
	log_processing([Goal,' is in the state.']).

%%% --------------------------------------------------------------------------------------------------
%%% Filtering
%%% --------------------------------------------------------------------------------------------------

filterRules(NegId,Goal,Requester,RuleList) :-
	filtering(NegId,Goal,Requester,public,[],RuleList),
	log_filtering(['New filtered set of policies found:',RuleList]).

filtering(NegId,Goal,Requester,Internal,RuleList,NewRuleList) :-
	filterTerm(in(NegId,Goal,_Goal,Requester,Internal,RuleList),out(_FilteredGoal,NewRuleList)).
	
% retrieves a list of filtered rules to be sent to the other party
%     NOTE1: whenever a literal to be executed by the requester is found, any other action to be executed by self in the rest of the SLD tree
%            is blurred. That is, no actions to be executed by self is in the set of filtered rules.
%     NOTE2: internal predicates are not shown in the set of fitered rules
            
filterTerms(in(_NegId,[],[],_Requester,_Internal,RuleList),out([],RuleList)) :- !.
filterTerms(in(NegId,[BoundGoal|BoundList],[UnboundGoal|UnboundList],Requester,Internal,RuleList),out(NewFilteredList,NewRuleList)) :-
	log_filtering(['Filtering terms ',BoundGoal|BoundList]),
	filterTerm(in(NegId,BoundGoal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,RuleList2)),
	filterTerms(in(NegId,BoundList,UnboundList,Requester,Internal,RuleList2),out(FilteredList,NewRuleList)),
	addToList(FilteredGoal,FilteredList,NewFilteredList),
	log_filtering(['Finished filtering terms ',BoundGoal|BoundList]).


% If @ is nested with same Issuer, it may be simplified
filterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)) :-
	log_filtering(['Can ',Goal,' be simplified?']),
	Goal = '@'('@'(G, Issuer), Issuer),
	!,
	log_filtering(['Simplifying ',Goal]),
	filterTerm(in(NegId,'@'(G, Issuer),UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)).

% If the term is found locally, then remote elements are not checked.
% TODO local process term should include the builtins (package calls)
filterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)) :-
	log_filtering(['Start local process of ',Goal]),
	demark(Goal),
	localFilterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)),
	log_filtering(['Local match found:',NewRuleList]),
	mark(Goal).

% If the term is not found locally, then remote elements are checked.
filterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)) :-
	checkMark(Goal),
	log_filtering(['Start remote process of ',Goal]),
	remoteFilterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)),
	log_filtering(['Remote match found:',Goal,' and NewRuleList=',NewRuleList]).
	

% NORMAL LOCAL RULES

% Constraints
localFilterTerm(in(_NegId,Goal,UnboundGoal,_Requester,_Internal,RuleList),out(UnboundGoal,RuleList)) :-
	log_filtering(['Is ',Goal,' a constraint?']),
	Goal = constraint(Constraint),
	!,
	log_filtering(['Calling ',Goal]),
	call(Constraint),
	log_filtering(['Call to ',Constraint,' successful']).

% TODO add a localProcessTerm for the builtin predicates
	
	
% Rules
localFilterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(UnboundGoal,NewRuleList)) :-
	log_filtering(['Is ',Goal,' a rule?']),
	rule(RuleId,Goal,BoundGuards,BoundBody),
	log_filtering([Goal,' is a rule: ',rule(RuleId,Goal,BoundGuards,BoundBody)]),
	rule(RuleId,FilteredGoal,UnboundGuards,UnboundBody),
	filterGuardsAndBody(in(NegId,Goal,BoundGuards,UnboundGuards,BoundBody,UnboundBody,Requester,Internal,RuleList),out(FilteredGuards,FilteredBody,RuleList2)),
	appendToListIfPublic(Internal,[rule(FilteredGoal,FilteredGuards,FilteredBody)],RuleList2,NewRuleList),
	log_filtering(['FilterTerm for rule finished with FilteredGoal=',UnboundGoal,' and NewRuleList=',NewRuleList]).

% Signed rules
localFilterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(UnboundGoal,NewRuleList)) :-
	log_filtering(['Is ',Goal,' a signed rule?']),
	(Goal = '@'(_, Issuer) ; Goal = '$'('@'(_ , Issuer), _)),
	signed(RuleId,rule(Goal,Guards,Body),Issuer),
	log_filtering([Goal,' is a signed rule: ',signed(RuleId,rule(Goal,Guards,Body),Issuer)]),
	signed(RuleId,rule(FilteredGoal,UnboundGuards,UnboundBody),UnboundIssuer),
	filterPolicy(in(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,Internal,RuleList),out(RuleList2)),
	filterGuardsAndBody(in(NegId,Goal,Guards,UnboundGuards,Body,UnboundBody,Requester,Internal,RuleList2),out(FilteredGuards,FilteredBody,RuleList3)),
	appendToListIfPublic(Internal,[signed(rule(FilteredGoal,FilteredGuards,FilteredBody),UnboundIssuer)],RuleList3,NewRuleList),
	log_filtering(['FilterTerm for rule finished with FilteredGoal=',UnboundGoal,' and NewRuleList=',NewRuleList]).
			    
% INTERNAL LOCAL RULES

% If the Goal is private, no requests to Requester can be found from here

% When an internal rules is found, no information from here is added to the set of filtered policies. 
%     However, two things may happen:
%     - Goal is ground: in this case Goal is then evaluated and its result may be
%       * true, in which case Goal is simply removed from the set of filtered policies
%       * false, in which case the current branch of the SLD tree fails
%     - Goal is not ground: in this case, no evaluation is performed and a symbol "blurred" is added to the set of filtered policies

% TODO I think I can remove all the Internal variables the way the code is now
			    
localFilterTerm(in(NegId,Goal,_UnboundGoal,Requester,_Internal,RuleList),out(FilteredGoal,RuleList)) :-
	log_filtering(['Is ',Goal,' an internal rule?']),
	rule(_RuleId,Goal,Guards,Body,private),
	log_filtering([Goal,' is a private rule:',rule(_RuleId,Goal,Guards,Body,private)]),
%	( (ground(Goal))
%	->
	processTerms(NegId,Guards,Requester,evaluate),
	processTerms(NegId,Body,Requester,evaluate),
	FilteredGoal = nil,
%	;
%	    FilteredGoal = blurred
%	),
	log_filtering(['FilterTerm for internal rule finished with FilteredGoal=',FilteredGoal,' and NewRuleList=',RuleList]).

% Signed rules
localFilterTerm(in(NegId,Goal,_UnboundGoal,Requester,_Internal,RuleList),out(FilteredGoal,RuleList)) :-
	log_filtering(['Is ',Goal,' an internal signed rule?']),
	(Goal = '@'(_, Issuer) ; Goal = '$'('@'(_ , Issuer), _)),
	signed(_RuleId,rule(Goal,Guards,Body),Issuer,private),
	log_filtering([Goal,' is a private signed rule: ',signed(_RuleId,rule(Goal,Guards,Body),Issuer,private)]),
%	( (ground(Goal))
%	->
	processPolicy(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,evaluate),
	processTerms(NegId,Guards,Requester,evaluate),
	processTerms(NegId,Body,Requester,evaluate),
	FilteredGoal = nil,
%	;
%	    FilteredGoal = blurred
%	),
	log_filtering(['FilterTerm for internal signed rule finished with FilteredGoal=',FilteredGoal,' and NewRuleList=',RuleList]).

% As a last case, check if the requester can be added
localFilterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)) :-
	log_filtering(['Contains ',Goal,' the requester?']),
	\+(Goal = '$'(_,  _)),
	log_filtering(['Adding the requester ($) to ',Goal]),
	remarkIfMarked(Goal,'$'(Goal, Requester)),
	filterTerm(in(NegId,'$'(Goal, Requester),UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)).

% Checks if there exists a policy protecting a signed rule
filterPolicy(in(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,Internal,RuleList),out(NewRuleList)) :-
	log_filtering(['Has ',Goal,' a protecting policy?']),
	policy(RuleId,signed(rule(Goal,Guards,Body),Issuer), PolicyGuards, PolicyBody),
	log_filtering([Goal,' has a protecting policy.']),
	!,
	policy(RuleId,signed(rule(UnboundGoal,UnboundGuards,UnboundBody),UnboundIssuer), UnboundPolicyGuards, UnboundPolicyBody),
	filterGuardsAndBody(in(NegId,Goal,PolicyGuards,UnboundPolicyGuards,PolicyBody,UnboundPolicyBody,Requester,Internal,RuleList),out(FilteredPolicyGuards,FilteredPolicyBody,RuleList2)),
	appendToListIfPublic(Internal,[policy(signed(rule(UnboundGoal,UnboundGuards,UnboundBody),UnboundIssuer), FilteredPolicyGuards, FilteredPolicyBody)],RuleList2,NewRuleList),
	log_filtering(['FilterTerm for protecting policy finished with NewRuleList=',NewRuleList]).

% If a signed rule contains a requester ($), the policy has to contain it too
% If a signed rule does not contain a requester ($), the policy might or might not contain it (depends
%    on whether it needs it or not
% Therefore, we also check for policies with the Goal $ Requester
filterPolicy(in(NegId,signed(rule(Goal,Guards,Body),Issuer),Requester,Internal,RuleList),out(NewRuleList)) :-
	\+(Goal = '$'(_, _)),
	log_filtering(['Expanding ',Goal,' with requester for protecting policy search.']),
	filterPolicy(in(NegId,signed(rule('$'(Goal, Requester),Guards,Body),Issuer),Requester,Internal,RuleList),out(NewRuleList)).
filterPolicy(in(_NegId,signed(rule(_Goal,_Guards,_Body),_Issuer),_Requester,_Internal,RuleList),out(RuleList)).

% REMOTE RULES

% requests to the other peer
% if issuer = self, then at this point the evaluation has failed
% TODO when using @ and @@ it may be different since we couldn't remove the @@ but if it was only @ then we could remove it

remoteFilterTerm(in(NegId,Goal,UnboundGoal,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)) :-
	log_filtering(['Is ',Goal,' a remote predicate?']),
	Goal = '@'(_, Issuer),
	self_alias(Alias),
	\+(Alias = Issuer),
	log_filtering([Goal,' is a remote predicate.']),
	remoteFilterSelect(in(NegId,Goal,UnboundGoal,Issuer,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)),
	log_filtering(['FilterTerm for remote term finished with FilteredGoal=',FilteredGoal,' and NewRuleList=',NewRuleList]).

% check if it is to be executed by the requester or a different peer

remoteFilterSelect(in(NegId,Goal,UnboundGoal,Issuer,Requester,Internal,RuleList),out(UnboundGoal,NewRuleList)) :-
	Issuer = Requester,
	log_filtering([Goal,' is a request to requester ',Requester]),
	addIfInState(in(NegId,Goal,Internal,RuleList),out(NewRuleList)).

remoteFilterSelect(in(NegId,Goal,UnboundGoal,Issuer,Requester,Internal,RuleList),out(FilteredGoal,NewRuleList)) :-
	\+(Issuer = Requester),
	log_filtering([Goal,' is a request to peer ',Issuer]),
	blurredIfNotInState(in(NegId,Goal,UnboundGoal,Internal,RuleList),out(FilteredGoal,NewRuleList)).

blurredIfNotInState(in(NegId,Goal,UnboundGoal,Internal,RuleList),out(UnboundGoal,NewRuleList)) :-
	checkState(NegId,Goal,UnboundGoal),
	appendToListIfPublic(Internal,[notification(UnboundGoal,successful)],RuleList,NewRuleList).

% if it failed, fail.
checkState(NegId,Goal,_UnboundGoal) :-
	log_filtering(['Is ',Goal,' in the state as failure?']),
	state(_RuleId,NegId,_NegStep,notification(Goal,failed),_Proof),
	!,
	log_filtering([Goal,' is in the state as failure.']),
	fail.

checkState(NegId,Goal,blurred) :-
	\+(state(_RuleId,NegId,_NegStep,notification(Goal,successful),_Proof)),
	!.

% if it was successful, add to the set of filtered rules
checkState(NegId,Goal,UnboundGoal) :-
	log_filtering(['Is ',Goal,' in the state as successful?']),
	state(RuleId,NegId,_NegStep,notification(Goal,successful),_Proof),
	log_filtering([Goal,' is in the state.as successful']),
	state(RuleId,NegId,_NegStep,notification(UnboundGoal,successful),_Proof).

addIfInState(in(NegId,Goal,Internal,RuleList),out(NewRuleList)) :-
	log_filtering(['Is ',Goal,' in the state?']),
	state(RuleId,NegId,_NegStep,notification(Goal,successful),_Proof),
	log_filtering([Goal,' is in the state.']),
	state(RuleId,NegId,_NegStep,notification(UnboundGoal,successful),_Proof),	
	appendToListIfPublic(Internal,[notification(UnboundGoal,successful)],RuleList,NewRuleList).
addIfInState(in(NegId,Goal,_Internal,RuleList),out(RuleList)) :-
	\+(state(_RuleId,NegId,_NegStep,notification(Goal,successful),_Proof)).

% verifies whether Goal is satisfied but it does not instantiate variables
% verify(Goal) :- not( not( Goal )).


% adds to the list if the term is not nil
addToList(nil,List,List) :- !.
addToList(Term,List,[Term|List]).

appendToListIfPublic(Internal,List1,List2,NewList) :-
	( (Internal = private)
	->
	    NewList = List2
	;
	    append(List1,List2,NewList)
	).

filterGuardsAndBody(in(NegId,_Goal,BoundGuards,UnboundGuards,BoundBody,UnboundBody,Requester,Internal,RuleList),out(FilteredGuards,FilteredBody,NewRuleList)) :-
	log_filtering(['Filtering guards ',BoundGuards]),
	filterTerms(in(NegId,BoundGuards,UnboundGuards,Requester,Internal,RuleList),out(FilteredGuards,RuleList2)),
	conditionalFiltering(in(NegId,BoundGuards,BoundBody,UnboundBody,Requester,Internal,RuleList2),out(FilteredBody,NewRuleList)),
	log_filtering(['Conditional filtering finished with FilteredBody=',FilteredBody]).

conditionalFiltering(in(NegId,BoundGuards,BoundBody,UnboundBody,Requester,Internal,RuleList),out(FilteredBody,NewRuleList)) :-
	log_filtering(['Does ',BoundGuards,' evaluate to true?']),
	processTerms(NegId,BoundGuards,Requester,evaluate),
	log_filtering([BoundGuards,' evaluates to true.']),
	!,
	filterTerms(in(NegId,BoundBody,UnboundBody,Requester,Internal,RuleList),out(FilteredBody,NewRuleList)).
conditionalFiltering(in(_NegId,_BoundGuards,_BoundBody,_UnboundBody,_Requester,_Internal,RuleList),out([blurred],RuleList)).


% Extracts the 2nd level of an AND-OR tree where the parent is the goal and children are in a OR list where each sublist represents an AND set of children
%     e.g., [ [a,b] [c,d] ] which represents ( (a AND b) OR (c AND d) )


%% --------------------------

log_processing(List) :-
	log_debug(['processing: '|List]).
log_filtering(List) :-
	log_debug(['filtering: '|List]).

printResultTree(_) :- init,fail.
printResultTree(X) :-
	printResultSubTree(X).

printResultSubTree([]).
printResultSubTree([resultTree(Goal,SubQueries,Proof,Trace,RemoteGoal,Delegator)|Rest]) :-
	writelist(2,[Goal]),
	writelist(5,SubQueries),
	writelist(5,Proof),
	writelist(5,Trace),
	writelist(5,[RemoteGoal]),
	writelist(5,[Delegator]),nl,
	printResultSubTree(Rest).
