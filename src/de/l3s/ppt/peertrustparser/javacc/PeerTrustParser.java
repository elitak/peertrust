/* Generated By:JavaCC: Do not edit this line. PeerTrustParser.java */
package de.l3s.ppt.peertrustparser.javacc;

import java.util.ArrayList;
import java.io.IOException;
import de.l3s.ppt.peertrustparser.*;
import de.l3s.ppt.log.Logger;

public class PeerTrustParser implements PeerTrustParserConstants {
  private String str;
  private static Logger logger = new Logger(PeerTrustParser.class);
  private int commonOffset = 0;
  public static final int TABS_SIZE = 8;

  public static PeerTrustParser createParser( String str, int commonOffset )
  throws IOException
  {
    logger.debug("createParser() : ENTER");
    logger.debug("createParser() : string to parse = " + str);
    logger.debug("createParser() : commonOffset = " + commonOffset);
    java.io.StringReader sr = new java.io.StringReader( str );
    java.io.Reader r = new java.io.BufferedReader( sr );
    PeerTrustParser peerTrustParser = new PeerTrustParser( r );
    peerTrustParser.str  = str;
    peerTrustParser.commonOffset = commonOffset;
    logger.debug("createParser() : EXIT");
    return peerTrustParser;
  }

  public ArrayList parse()
  throws ParseException, IOException
  {
    logger.info("parse() : ENTER");
    ArrayList entries = new ArrayList();

    try {
      entries = Input(entries);
      logger.debug("parse() : input has been parsed in a single run");
    } catch( ParseException e ) {
      logger.debug("parse() : ParseException was thrown, exception was: " + e.toString());
      try {
        entries = skipDamagedPartAndParseAhead(entries);
      } catch (Exception ex) {
        logger.error("parse() : exception was thrown by skipDamagedPartAndParseAhead(), exception was: " + ex.toString());
        logger.error("parse() : marking unparsed tail as damaged part");
        if (entries.size() != 0 && entries.get(entries.size() - 1) instanceof Integer) {
          entries.remove(entries.size() - 1);
          logger.debug("parse() : removing last entry");
        }
        entries.add(new Integer(str.length() - 1 + commonOffset));
        logger.debug("parse() : adding an entry");
      }
    } catch( TokenMgrError ex ) {
      logger.debug("parse() : TokenMgrError was thrown, exception was: " + ex.toString());
      try {
        entries = skipDamagedPartAndParseAhead(entries);
      } catch (Exception e) {
        logger.error("parse() : exception was thrown by skipDamagedPartAndParseAhead(), exception was: " + e.toString());
        logger.error("parse() : marking unparsed tail as damaged part");
        if (entries.size() != 0 && entries.get(entries.size() - 1) instanceof Integer) {
          entries.remove(entries.size() - 1);
          logger.debug("parse() : removing last entry");
        }
        entries.add(new Integer(str.length() - 1 + commonOffset));
        logger.debug("parse() : adding an entry");
      }
    }
    logger.info("parse() : number of parsed entries = " + entries.size());
    logger.info("parse() : EXIT");
    return entries;
  }

  private int calculateOffset(int line, int column) {
    int offset = 0;
    for (int i = 0; i < line - 1; i++) {
      offset = str.indexOf('\n', offset) + 1;
      if (offset == 0) {
        logger.error("calculateOffset() : can not calculate offset for: line; column: " + line + "; " + column);
        offset = -1;
        break;
      }
    }
    if (offset != -1) {
      if (str.charAt(offset) == '\r') {
        offset++;
      }
      for (int columnNumber = 0; columnNumber < column - 1; columnNumber++) {
        if (str.charAt(offset) == '\t') {
          columnNumber += TABS_SIZE - (columnNumber - (int) (columnNumber / TABS_SIZE) * TABS_SIZE) - 1;
        }
        offset++;
      }
      //does not work with tabs:
      //offset += column - 1;
      offset += commonOffset;
    }
    return offset;
  }

  private ArrayList skipDamagedPartAndParseAhead(ArrayList parsedEntries)
    throws ParseException, IOException {

    logger.debug("skipDamagedPartAndParseAhead() : ENTER");
    ArrayList entries = (ArrayList)parsedEntries.clone();

    int offset = 0;
    if (entries == null) {
      entries = new ArrayList();
    }
    logger.debug("skipDamagedPartAndParseAhead() : entries size on enter: " + entries.size());
    if (entries.size() != 0) {
      if (entries.get(entries.size() - 1) instanceof Rule) {
        offset = ((Rule)entries.get(entries.size() - 1)).offsetInInput;
      } else {
        offset = ((Integer)entries.get(entries.size() - 1)).intValue();
      }
      offset++;
      offset -= commonOffset;
      if (offset < str.length() && str.charAt(offset) == '\r') {
        offset++;
      }
    }
    logger.debug("skipDamagedPartAndParseAhead() : offset on enter: " + offset);

    boolean done = false;
    int dotOffset = str.indexOf(Constants.DOT, offset);
    int delimiterOffset = str.indexOf('\n', offset);

    logger.debug("skipDamagedPartAndParseAhead() : dotOffset: " + dotOffset);
    logger.debug("skipDamagedPartAndParseAhead() : delimiterOffset: " + delimiterOffset);

    if (dotOffset == -1 && delimiterOffset == -1) {
      if (entries.size() != 0 && entries.get(entries.size() - 1) instanceof Integer) {
        entries.remove(entries.size() - 1);
        logger.debug("skipDamagedPartAndParseAhead() : removing last entry");
      }
      entries.add(new Integer(str.length() - 1 + commonOffset));
      logger.debug("skipDamagedPartAndParseAhead() : adding an entry");
      done = true;
      logger.debug("skipDamagedPartAndParseAhead() : done: " + done);
    } else {
      if (dotOffset == -1 && delimiterOffset != -1) {
        offset = delimiterOffset + 1;
        if (offset < str.length() && str.charAt(offset) == '\r') {
          offset++;
        }
      }
      if (dotOffset != -1 && delimiterOffset == -1) {
        offset = dotOffset + Constants.DOT.length();
      }
      if (dotOffset != -1 && delimiterOffset != -1) {
        if (dotOffset < delimiterOffset) {
          offset = dotOffset + Constants.DOT.length();
        } else {
          offset = delimiterOffset + 1;
          if (offset < str.length() && str.charAt(offset) == '\r') {
            offset++;
          }
        }
      }
      logger.debug("skipDamagedPartAndParseAhead() : offset: " + offset);
      logger.debug("skipDamagedPartAndParseAhead() : done: " + done);
      if (entries.size() != 0 && entries.get(entries.size() - 1) instanceof Integer) {
        entries.remove(entries.size() - 1);
        logger.debug("skipDamagedPartAndParseAhead() : removing last entry");
      }
      entries.add(new Integer(offset - 1 + commonOffset));
      logger.debug("skipDamagedPartAndParseAhead() : adding an entry");
    }
    if (!done) {
      ArrayList tail = new ArrayList();
      if (offset < str.length()) {
        logger.debug("skipDamagedPartAndParseAhead() : creating new parser to parse the tail");
        PeerTrustParser parser = PeerTrustParser.createParser(str.substring(offset), offset + commonOffset);
        tail = parser.parse();
        logger.debug("skipDamagedPartAndParseAhead() : tail size: " + tail.size());
        if (entries.size() != 0
           && entries.get(entries.size() - 1) instanceof Integer
           && tail.size() != 0
           && tail.get(0) instanceof Integer) {
         entries.remove(entries.size() - 1);
         logger.debug("skipDamagedPartAndParseAhead() : removing last entry");
        }
        for (int i = 0; i < tail.size(); i++) {
          logger.debug("skipDamagedPartAndParseAhead() : adding tail element to the entries");
          Object obj = tail.get(i);
          entries.add(obj);
        }
      } else {
        if (entries.size() != 0 && entries.get(entries.size() - 1) instanceof Integer) {
          entries.remove(entries.size() - 1);
          logger.debug("skipDamagedPartAndParseAhead() : removing last entry");
        }
        entries.add(new Integer(str.length() - 1 + commonOffset));
        logger.debug("skipDamagedPartAndParseAhead() : adding an entry");
      }
    }
    logger.debug("skipDamagedPartAndParseAhead() : entries size on exit: " + entries.size());
    logger.debug("skipDamagedPartAndParseAhead() : EXIT");
    return entries;
  }

  final public ArrayList Input(ArrayList entries) throws ParseException {
  Rule rule = null;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
      case LOWER_CASE:
      case UPPER_CASE:
      case UNDERSCORE:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      rule = Rule();
     entries.add(rule);
    }
    jj_consume_token(0);
   {if (true) return entries;}
    throw new Error("Missing return statement in function");
  }

  final public Rule Rule() throws ParseException {
  ExtendedLiteral head = null;
  Rule rule = null;
  boolean hasRuleSeparator = false;
  RuleBody body = null;
  ArrayList temp = null;
  Token t = null;
  int endOffset;
    head = ExtendedLiteral();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIGNED_BY:
    case RULE_SEPARATOR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIGNED_BY:
        temp = SignedByElement();
        if (temp.size() == 3) {
          body = new RuleBody(null, (StringDescription)temp.get(0), (StringDescription)temp.get(1), (Guards)temp.get(2));
        } else {
          body = new RuleBody(null, (StringDescription)temp.get(0), (StringDescription)temp.get(1), null);
        }
        break;
      case RULE_SEPARATOR:
        jj_consume_token(RULE_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGIT:
        case SIGNED_BY:
        case LOWER_CASE:
        case UPPER_CASE:
        case UNDERSCORE:
          body = RuleBody();
          break;
        default:
          jj_la1[1] = jj_gen;
          ;
        }
       hasRuleSeparator = true;
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    t = jj_consume_token(DOT);
    endOffset = calculateOffset(t.endLine, t.endColumn);
    rule = new Rule(head, hasRuleSeparator, body, endOffset);
    {if (true) return rule;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList SignedByElement() throws ParseException {
  StringDescription signedBy = null;
  Guards body = null;
  ArrayList list = new ArrayList();
  Token t = null;
    t = jj_consume_token(SIGNED_BY);
    list.add(new StringDescription(t.image,
                                   calculateOffset(t.beginLine, t.beginColumn),
                                   calculateOffset(t.endLine, t.endColumn),
                                   false));
    jj_consume_token(OPENING_SQUARE_BRACKET);
    signedBy = StringExtended();
   list.add(signedBy);
    jj_consume_token(CLOSING_SQUARE_BRACKET);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIGIT:
    case LOWER_CASE:
    case UPPER_CASE:
    case UNDERSCORE:
      body = Guards();
     list.add(body);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public StringDescription StringExtended() throws ParseException {
  StringBuffer buff = new StringBuffer();
  char c;
  Token t;
  int beginOffset, endOffset;
  boolean isConstant = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIGIT:
    case LOWER_CASE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
        t = jj_consume_token(DIGIT);
        break;
      case LOWER_CASE:
        t = jj_consume_token(LOWER_CASE);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        isConstant = true;
        c = (char)t.image.charAt(0);
        buff.append(c);
        beginOffset = calculateOffset(t.beginLine, t.beginColumn);
      break;
    case UPPER_CASE:
    case UNDERSCORE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UPPER_CASE:
        t = jj_consume_token(UPPER_CASE);
        break;
      case UNDERSCORE:
        t = jj_consume_token(UNDERSCORE);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
       c = (char)t.image.charAt(0);
       buff.append(c);
       beginOffset = calculateOffset(t.beginLine, t.beginColumn);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
      case LOWER_CASE:
      case UPPER_CASE:
      case UNDERSCORE:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
        t = jj_consume_token(DIGIT);
        break;
      case LOWER_CASE:
        t = jj_consume_token(LOWER_CASE);
        break;
      case UPPER_CASE:
        t = jj_consume_token(UPPER_CASE);
        break;
      case UNDERSCORE:
        t = jj_consume_token(UNDERSCORE);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (t.specialToken != null) {
        {if (true) throw new ParseException("whitespace(s) in a string");}
      }
      c = (char)t.image.charAt(0);
      buff.append(c);
    }
    endOffset = calculateOffset(t.endLine, t.endColumn);
    {if (true) return(new StringDescription(buff.toString(), beginOffset, endOffset, isConstant));}
    throw new Error("Missing return statement in function");
  }

  final public ExtendedLiteral ExtendedLiteral() throws ParseException {
  ExtendedLiteral extLiteral = null;
  Literal literal = null;
  Issuer issuer = null;
  Requester requester = null;
    literal = Literal();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ISSUER_CHAR:
      jj_consume_token(ISSUER_CHAR);
      issuer = Issuer();
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REQUESTER_CHAR:
      jj_consume_token(REQUESTER_CHAR);
      requester = Requester();
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    extLiteral = new ExtendedLiteral(literal, issuer, requester);
    {if (true) return extLiteral;}
    throw new Error("Missing return statement in function");
  }

  final public RuleBody RuleBody() throws ParseException {
  StringDescription signedBy = null;
  StringDescription commandWord = null;
  Guards body = null;
  Guards policy = null;
  boolean verticalSlash = false;
  ArrayList beforeSignedBy = null;
  ArrayList temp = null;
  boolean simpleRule = true;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SIGNED_BY:
      temp = SignedByElement();
        commandWord = (StringDescription)temp.get(0);
        signedBy = (StringDescription)temp.get(1);
        if (temp.size() == 3) {
          body = (Guards)temp.get(2);
        }
        simpleRule = false;
      break;
    case DIGIT:
    case LOWER_CASE:
    case UPPER_CASE:
    case UNDERSCORE:
      beforeSignedBy = ExtendedLiterals();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIGNED_BY:
      case VERTICAL_SLASH:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SIGNED_BY:
          temp = SignedByElement();
            commandWord = (StringDescription)temp.get(0);
            signedBy = (StringDescription)temp.get(1);
            if (temp.size() == 3) {
              body = (Guards)temp.get(2);
            }
            policy = new Guards(beforeSignedBy, null, false);
            simpleRule = false;
          break;
        case VERTICAL_SLASH:
          jj_consume_token(VERTICAL_SLASH);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DIGIT:
          case LOWER_CASE:
          case UPPER_CASE:
          case UNDERSCORE:
            temp = ExtendedLiterals();
                body = new Guards(beforeSignedBy, temp, true);
                simpleRule = false;
            break;
          case SIGNED_BY:
            temp = SignedByElement();
                commandWord = (StringDescription)temp.get(0);
                signedBy = (StringDescription)temp.get(1);
                if (temp.size() == 3) {
                  body = (Guards)temp.get(2);
                }
                policy = new Guards(beforeSignedBy, null, true);
                simpleRule = false;
            break;
          default:
            jj_la1[12] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (simpleRule) {
      body = new Guards(beforeSignedBy, null, false);
    }
    {if (true) return new RuleBody(policy, commandWord, signedBy, body);}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList ExtendedLiterals() throws ParseException {
  ArrayList list = new ArrayList();
  ExtendedLiteral extLiteral = null;
    extLiteral = ExtendedLiteral();
   list.add(extLiteral);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      extLiteral = ExtendedLiteral();
     list.add(extLiteral);
    }
   {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public Guards Guards() throws ParseException {
  ArrayList beforeSlash = null;
  ArrayList afterSlash = null;
  boolean hasVerticalSlash = false;
    beforeSlash = ExtendedLiterals();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VERTICAL_SLASH:
      jj_consume_token(VERTICAL_SLASH);
     hasVerticalSlash = true;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
      case LOWER_CASE:
      case UPPER_CASE:
      case UNDERSCORE:
        afterSlash = ExtendedLiterals();
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
   {if (true) return new Guards(beforeSlash, afterSlash, true);}
    throw new Error("Missing return statement in function");
  }

  final public Literal Literal() throws ParseException {
  StringDescription predicate = null;
  Literal literal = null;
  ArrayList arguments = null;
    predicate = StringExtended();
    jj_consume_token(OPENING_BRACKET);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIGIT:
    case LOWER_CASE:
    case UPPER_CASE:
    case UNDERSCORE:
    case OPENING_SQUARE_BRACKET:
      arguments = Arguments();
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    jj_consume_token(CLOSING_BRACKET);
    literal = new Literal(predicate, arguments);
    {if (true) return literal;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList Arguments() throws ParseException {
  ArrayList arguments = new ArrayList();
  ArrayList internalArguments = null;
  StringDescription str = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIGIT:
    case LOWER_CASE:
    case UPPER_CASE:
    case UNDERSCORE:
      str = StringExtended();
       arguments.add(str);
      break;
    case OPENING_SQUARE_BRACKET:
      jj_consume_token(OPENING_SQUARE_BRACKET);
      internalArguments = Arguments();
      jj_consume_token(CLOSING_SQUARE_BRACKET);
       arguments.add(internalArguments);
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
      case LOWER_CASE:
      case UPPER_CASE:
      case UNDERSCORE:
        str = StringExtended();
         arguments.add(str);
        break;
      case OPENING_SQUARE_BRACKET:
        jj_consume_token(OPENING_SQUARE_BRACKET);
        internalArguments = Arguments();
        jj_consume_token(CLOSING_SQUARE_BRACKET);
         arguments.add(internalArguments);
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
   {if (true) return arguments;}
    throw new Error("Missing return statement in function");
  }

  final public Issuer Issuer() throws ParseException {
  StringDescription primaryIssuer = null;
  Issuer additionalIssuer = null, issuer = null;
    primaryIssuer = StringExtended();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ISSUER_CHAR:
      jj_consume_token(ISSUER_CHAR);
      additionalIssuer = Issuer();
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    issuer = new Issuer(primaryIssuer, additionalIssuer);
    {if (true) return issuer;}
    throw new Error("Missing return statement in function");
  }

  final public Requester Requester() throws ParseException {
  StringDescription primaryRequester = null;
  Requester additionalRequester = null, requester = null;
    primaryRequester = StringExtended();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REQUESTER_CHAR:
      jj_consume_token(REQUESTER_CHAR);
      additionalRequester = Requester();
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    requester = new Requester(primaryRequester, additionalRequester);
    {if (true) return requester;}
    throw new Error("Missing return statement in function");
  }

  public PeerTrustParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[25];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x3a0,0x3e0,0x10040,0x10040,0x3a0,0xa0,0x300,0x3a0,0x3a0,0x3a0,0x400,0x800,0x3e0,0x40040,0x40040,0x3e0,0x20000,0x3a0,0x40000,0x43a0,0x43a0,0x20000,0x43a0,0x400,0x800,};
   }

  public PeerTrustParser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new PeerTrustParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  public PeerTrustParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new PeerTrustParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  public PeerTrustParser(PeerTrustParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  public void ReInit(PeerTrustParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[21];
    for (int i = 0; i < 21; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 25; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 21; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
